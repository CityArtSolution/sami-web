<?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;use Modules\Booking\Models\Booking;use Modules\Promotion\Models\Coupon;use App\Models\LoyaltyPoint;use App\Models\Invoice;use Modules\Booking\Models\BookingTransaction;use Modules\Wallet\Models\Wallet;use App\Models\Setting;use Modules\Product\Models\Cart;use Modules\Product\Models\Order;use Modules\Product\Models\OrderGroup;use Modules\Product\Models\OrderItem;use Illuminate\Support\Facades\Log;use Illuminate\Support\Facades\Http;class PaymentchanalController extends Controller{    public function payment(Request $request){                $method = $request->paymentMethod;        $type_page = $request->ids ? 'payment' : 'cart';        if ($method == 'cash'){                        return $this->payWithCash($request);                    }elseif($method == 'card'){                        return $this->payWithCard($request , $type_page);                    }elseif($method == 'wallet'){                        return $this->payWithWallet($request , $type_page);                    }elseif($method == 'points'){                        return $this->payWithPoints($request , $type_page);                    }elseif($method == 'tamara'){                        return $this->payWithTamara($request);                    }elseif($method == 'tabby'){                        return $this->payWithTabby($request , $type_page);                    }else{                        return redirect()->back()->with('error', __('messages.invalid_payment_method'));                    }    }        private function payWithCash($request)    {            }        private function payWithCard($request , $type_page)    {        $final = $this->calculateTotal($type_page , $request->invoiceCopon)['total'];        $discountAmount = $this->calculateTotal($type_page , $request->invoiceCopon)['discountAmount'];        return redirect()->to('/pay?type=cart&amount=' . $final . '&discountAmount=' . $discountAmount . '&page=' . $type_page);    }        private function payWithWallet($request , $type_page)    {        $final = $this->calculateTotal($type_page , $request->invoiceCopon)['total'];        $discountAmount = $this->calculateTotal($type_page , $request->invoiceCopon)['discountAmount'];        $userId = auth()->id();                $objBalance = Wallet::where('user_id' ,$userId)->first();        $Balance = ((int) $objBalance->amount) ?? 0;        if($final > $Balance ){            return redirect()->back()->with('error', __('messages.insufficient_balance'));        }        if($type_page == 'payment'){            $cartIds = Booking::where('user_id', $userId)->where('payment_status', 0)->where('payment_type', 'payment')->pluck('id')->toArray();        }else{            $cartIds = Booking::where('user_id', $userId)->where('payment_status', 0)->where('payment_type', 'cart')->pluck('id')->toArray();        }                $this->addLoyaltyPoints($userId, $final);        $inv = $this->storeInvoice($userId, $discountAmount, $final, $cartIds);        $this->paymentSuccess( $cartIds ,  'INV-'.$inv , 'wallet');                $objBalance->amount -= $final;        $objBalance->save();                Booking::whereIn('id', $cartIds)->update(['payment_status' => 1]);        return view('components.frontend.status.CAPTURED');    }        private function payWithTamara($request)    {        $final = $this->calculateTotal($request->invoiceCopon);        // كود Tamara    }         private function payWithTabby(Request $request, $typePage)    {        $userId = auth()->id();            $cartItems = Booking::with('service.service', 'products.product')            ->where('created_by', $userId)            ->where('status', 'pending')            ->whereNull('deleted_by')            ->where('payment_status', 0)            ->when($typePage == 'payment', fn($q) => $q->where('payment_type', 'payment'))            ->when($typePage == 'cart', fn($q) => $q->where('payment_type', 'cart'))            ->get();            if ($cartItems->isEmpty()) {            return redirect()->back()->with('error', __('messages.cart_empty'));        }            $orderItems = [];        $cartIds = [];        $totalAmount = 0;            foreach ($cartItems as $item) {            $cartIds[] = $item->id;                // Services            if ($item->service) {                $bookingService = $item->service;                $orderItems[] = [                    "title" => $bookingService->service->name ?? 'Service',                    "unit_price" => (float) ($bookingService->service_price ?? 0),                    "quantity" => 1,                    "category" => "Service"                ];                $totalAmount += $bookingService->service_price ?? 0;            }                // Products            if ($item->products && $item->products->count() > 0) {                foreach ($item->products as $p) {                    $orderItems[] = [                        "title" => $p->product->name ?? 'Product',                        "unit_price" => (float) ($p->product_price ?? 0),                        "quantity" => (int) ($p->product_qty ?? 1),                        "category" => "Product"                    ];                    $totalAmount += ($p->product_price ?? 0) * ($p->product_qty ?? 1);                }            }        }            $invoiceRef = "INV-" . implode('-', $cartIds);        $currency = \Currency::getDefaultCurrency()->currency_code;            $payload = [            "merchant_code" => env("TABBY_MERCHANT_CODE"),            "lang" => "ar",            "payment" => [                "amount" => $totalAmount,                "currency" => $currency,                "description" => "Invoice #" . $invoiceRef            ],            "buyer" => [                "email" => auth()->user()->email,                "phone" => auth()->user()->phone ?? '',                "name" => auth()->user()->name ?? ''            ],            "order" => [                "reference_id" => $invoiceRef,                "items" => $orderItems            ],            "callback" => [                "success" => route("tabby.success", ["invoice" => $invoiceRef]),                "failure" => route("tabby.fail", ["invoice" => $invoiceRef]),                "cancel" => route("tabby.cancel", ["invoice" => $invoiceRef]),            ]        ];            try {            $response = Http::withHeaders([                'Authorization' => 'Bearer ' . env('TABBY_SECRET_KEY'),                'Content-Type' => 'application/json'            ])->post("https://api.tabby.ai/api/v2/checkout", $payload);                $data = $response->json();            $paymentUrl = $data['payment']['url'] ?? $data['checkout_url'] ?? null;                if (!$response->successful() || !$paymentUrl) {                Log::error('Tabby Error', ['response' => $data]);                return redirect()->back()->with('error', __('messages.payment_gateway_error'));            }                return redirect()->away($paymentUrl);            } catch (\Throwable $e) {            Log::error('Tabby Exception', ['message' => $e->getMessage()]);            return redirect()->back()->with('error', __('messages.payment_gateway_error'));        }    }    public function tabbySuccess($invoice)    {        $cartIds = array_map('intval', explode('-', $invoice));        $userId = auth()->id();            $typePage = 'payment';         $totals = $this->calculateTotal($typePage);         $finalTotal = $totals['total'];        $discountAmount = $totals['discountAmount'];            Booking::whereIn('id', $cartIds)            ->update([                'status' => 'completed',                'payment_status' => 1            ]);            $this->addLoyaltyPoints($userId, $finalTotal);            $invId = $this->storeInvoice($userId, $discountAmount, $finalTotal, $cartIds);            $this->paymentSuccess($cartIds, 'TABBY-' . $invoice, 'tabby');            return redirect()->route('backend.bookings.index')            ->with('success', __('messages.payment_success'));    }    public function tabbyFail($invoice)    {        return redirect()->route('backend.bookings.index')            ->with('error', __('messages.payment_failed'));    }    public function tabbyCancel($invoice)    {        return redirect()->route('backend.bookings.index')            ->with('warning', __('messages.payment_cancelled'));    }        private function payWithPoints($request , $type_page)    {        $final = $this->calculateTotal($type_page , $request->invoiceCopon)['total'];        $discountAmount = $this->calculateTotal($type_page , $request->invoiceCopon)['discountAmount'];        $userId = auth()->id();        $ratePerPoint = Setting::get('point_value') ?? 0.5;        $loyalty = LoyaltyPoint::where('user_id' ,$userId)->first();                $currentPoints = $loyalty ? $loyalty->points : 0;        $loyaltyBalance = $currentPoints * $ratePerPoint;        $requiredPoints = ceil($final / $ratePerPoint);        if($final > $loyaltyBalance ){            return redirect()->back()->with('error', __('messages.insufficient_loyalty_points'));        }                if($type_page == 'payment'){            $cartIds = Booking::where('user_id', $userId)->where('payment_status', 0)->where('payment_type', 'payment')->pluck('id')->toArray();        }else{            $cartIds = Booking::where('user_id', $userId)->where('payment_status', 0)->where('payment_type', 'cart')->pluck('id')->toArray();        }        $this->addLoyaltyPoints($userId, $final);        $inv = $this->storeInvoice($userId, $discountAmount, $final, $cartIds);        $this->paymentSuccess( $cartIds ,  'INV-'.$inv , 'loyalty');        $loyalty->points -= $requiredPoints;        $loyalty->save();                Booking::whereIn('id', $cartIds)->update(['payment_status' => 1]);        return view('components.frontend.status.CAPTURED');    }        private function calculateTotal($type_page , $couponCode = null)    {        // check validition total        if($type_page == 'payment'){            $cartItems = Booking::with('service.service', 'products.product' , 'service.employee')->where('created_by', auth()->user()->id)->where('status', 'pending')->where('payment_status', 0)->where('payment_type', 'payment')->whereNull('deleted_by')->get();        }else{            $cartItems = Booking::with('service.service', 'products.product' , 'service.employee')->where('created_by', auth()->user()->id)->where('status', 'pending')->where('payment_status', 0)->where('payment_type', 'cart')->whereNull('deleted_by')->get();        }        $total = 0;                foreach ($cartItems as $item) {                        if ($item->service) {                $total += (float) $item->service->service_price - ($item->service->discount_amount ?? 0);            }                    if ($item->products && count($item->products) > 0) {                        foreach ($item->products as $p) {                    $price = (float) $p->product_price;                    $qty   = (int) $p->product_qty;                            $total += $price * $qty;                }            }        }        // culc Tax & Service        $productPrice = $cartItems->sum(function ($item) {            return $item->products ? $item->products->sum(fn($p) => ($p->product_price ?? 0) * ($p->product_qty ?? 1)): 0;        });        $Tax_Service = getBookingTaxamount($total, 0, null )['total_tax_amount'] + getTaxamount($productPrice)['total_tax_amount'];        $finaltotal = $total +  $Tax_Service;        $discountAmount = 0;                if(isset($couponCode) && $couponCode != ''){            $coupon = Coupon::where('coupon_code', $couponCode)                ->where('is_expired', 0)                ->first();            if (!$coupon) {                return redirect()->back()->with('error', __('messages.invalid_coupon'));            }            $services = $coupon->services;             if (!in_array(0, $services)) {                return redirect()->back()->with('error', __('messages.invalid_coupon'));            }            if($coupon->type == 'percent'){                $discountAmount = ($finaltotal * $coupon->discount_percentage) / 100;            } else {                $discountAmount = $coupon->discount_amount;            }                                $finaltotal -= $discountAmount;            if($finaltotal < 0) $finaltotal = 0;        }        return ['total' => $finaltotal , 'discountAmount' => $discountAmount];    }    public function addLoyaltyPoints($userId, $paidAmount)    {        $points_per_100 = Setting::get('points_per_100') ?? 5;        $pointsToAdd = floor($paidAmount / 100) * $points_per_100;        if ($pointsToAdd <= 0) {            return;        }        $loyalty = LoyaltyPoint::firstOrNew(['user_id' => $userId]);        $loyalty->points = ($loyalty->points ?? 0) + $pointsToAdd;        $loyalty->save();    }    private function storeInvoice($userId, $discountAmount, $finalTotal, $cartIds)    {        $inv = Invoice::create([            'user_id' => $userId,            'cart_ids' => json_encode($cartIds),            'discount_amount' => $discountAmount,            'loyalty_points_discount' => 0,            'final_total' => $finalTotal,        ]);        return $inv->id;    }    private function paymentSuccess( array $cartIds , $tapId = null , $paymentMethod): void    {        foreach ($cartIds as $bookingId) {            BookingTransaction::create([                'booking_id'     => $bookingId,                'external_transaction_id' => $tapId,                'transaction_type' => $paymentMethod,                'payment_status' => 1,            ]);        }    }            // Order Creation    public function complete(Request $request)    {        $user = auth()->user();        $userId = $user->id;        $location_id = $request->location_id;        $carts = Cart::where('user_id', $userId)->where('location_id', $location_id)->get();        if (count($carts) > 0) {            // check carts available stock -- todo::[update version] -> run this check while storing OrderItems            foreach ($carts as $cart) {                $productVariationStock = $cart->product_variation->product_variation_stock ? $cart->product_variation->product_variation_stock->stock_qty : 0;                if ($cart->qty > $productVariationStock) {                    $message = $cart->product_variation->product->name.' is out of stock';                    return response()->json(['message' => $message, 'status' => false]);                }            }            // create new order group            $orderGroup = new OrderGroup;            $orderGroup->user_id = $userId;            $orderGroup->shipping_address_id = $request->shipping_address_id;            $orderGroup->billing_address_id = $request->billing_address_id;            $orderGroup->location_id = $location_id;            $orderGroup->phone_no = $request->phone;            $orderGroup->alternative_phone_no = $request->alternative_phone;            $orderGroup->sub_total_amount = getSubTotal($carts, false, '', false);            $orderGroup->total_tax_amount = 0;            $orderGroup->total_coupon_discount_amount = 0;            $orderGroup->type = 'online';            $logisticZone = LogisticZone::where('id', $request->chosen_logistic_zone_id)->first();            $orderGroup->total_shipping_cost = $logisticZone->standard_delivery_charge;            $orderGroup->total_tips_amount = $request->tips;            $orderGroup->grand_total_amount = $orderGroup->sub_total_amount + $orderGroup->total_tax_amount + $orderGroup->total_shipping_cost + $orderGroup->total_tips_amount - $orderGroup->total_coupon_discount_amount;            $orderGroup->save();            // order -> todo::[update version] make array for each vendor, create order in loop            $order = new Order;            $order->order_group_id = $orderGroup->id;            $order->user_id = $userId;            $order->location_id = $location_id;            $order->total_admin_earnings = $orderGroup->grand_total_amount;            $order->logistic_id = $logisticZone->logistic_id;            $order->logistic_name = optional($logisticZone->logistic)->name;            $order->shipping_cost = $orderGroup->total_shipping_cost; // todo::[update version] calculate for each vendors            $order->tips_amount = $orderGroup->total_tips_amount; // todo::[update version] calculate for each vendors            $order->save();            // order items            $total_points = 0;            foreach ($carts as $cart) {                $orderItem = new OrderItem;                $orderItem->order_id = $order->id;                $orderItem->product_variation_id = $cart->product_variation_id;                $orderItem->qty = $cart->qty;                $orderItem->location_id = $location_id;                $orderItem->unit_price = variationDiscountedPrice($cart->product_variation->product, $cart->product_variation);                $orderItem->total_tax = 0;                $orderItem->total_price = $orderItem->unit_price * $orderItem->qty;                $orderItem->save();                $product = $cart->product_variation->product;                $product->total_sale_count += $orderItem->qty;                // minus stock qty                try {                    $productVariationStock = $cart->product_variation->product_variation_stock;                    $productVariationStock->stock_qty -= $orderItem->qty;                    $productVariationStock->save();                } catch (\Throwable $th) {                    //throw $th;                }                $product->stock_qty -= $orderItem->qty;                $product->save();                // category sales count                if ($product->categories()->count() > 0) {                    foreach ($product->categories as $category) {                        $category->total_sale_count += $orderItem->qty;                        $category->save();                    }                }                $cart->delete();            }            $order->save();            // payment gateway integration & redirection            $orderGroup->payment_method = $request->payment_method;            $orderGroup->save();            return true;        }    }}